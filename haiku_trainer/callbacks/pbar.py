# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/01_callback.pbar.ipynb.

# %% auto 0
__all__ = ['ProgbarLogger']

# %% ../../nbs/01_callback.pbar.ipynb 2
from ..core import *
import haiku as hk
import importlib

if importlib.util.find_spec("ipywidgets") is not None:
    from tqdm.auto import tqdm 
else:
    from tqdm import tqdm 

# %% ../../nbs/01_callback.pbar.ipynb 3
def _update_pbar_n(pbar: tqdm, n: int):
    pbar.n = n
    pbar.refresh()

# %% ../../nbs/01_callback.pbar.ipynb 4
class ProgbarLogger(Callback):
    def __init__(self, ): 
        self._train_pbar = None
        self._valid_pbar = None
        self._batch_idx = None

    @property
    def train_pbar(self) -> tqdm: return self._train_pbar

    @property
    def valid_pbar(self) -> tqdm: return self._valid_pbar

    @train_pbar.setter
    def train_pbar(self, pbar: tqdm): self._train_pbar = pbar

    @valid_pbar.setter
    def valid_pbar(self, pbar: tqdm): self._valid_pbar = pbar
    
    @property
    def num_train_batches(self) -> int: 
        return self.trainer.num_train_batches
    
    @property
    def num_valid_batches(self) -> int:
        return self.trainer.num_val_batches
    
    @property
    def num_epoches(self) -> int:
        return self.trainer.n_epochs

    def init_train_pbar(self):
        return tqdm(
            desc='Training', leave=True, dynamic_ncols=True,
            file=sys.stdout, smoothing=0, position=0
        )
    
    def init_val_pbar(self):
        return tqdm(
            desc='Validation', leave=False, dynamic_ncols=True,
            file=sys.stdout, smoothing=0, position=0
        )
    
    def on_train_begin(self, state: TrainState):
        self.train_pbar = self.init_train_pbar()

    def on_epoch_begin(self, state: TrainState):
        self.train_pbar.reset(self.num_train_batches)
        self.train_pbar.initial = 0
        self.train_pbar.set_description(f"Epoch {state.epoch}")
        self._batch_idx = 0

    def on_train_batch_end(self, state: TrainState):
        self._batch_idx += 1
        _update_pbar_n(self.train_pbar, self._batch_idx)
        self.train_pbar.set_postfix(state.logs)
        
    def on_epoch_end(self, state: TrainState):
        if not self.train_pbar.disable:
            self.train_pbar.set_postfix(state.logs)

    def on_train_end(self, state: TrainState):
        self.train_pbar.close()

    def on_val_begin(self, state: TrainState):
        self.valid_pbar = self.init_val_pbar()
        self.valid_pbar.reset(self.num_valid_batches)
        self.valid_pbar.initial = 0
        self.valid_pbar.set_description(f"Validation Dataloader")

    def on_val_batch_end(self, state: TrainState):
        self.valid_pbar.update(1)

    def on_val_end(self, state: TrainState):
        self.valid_pbar.close()

